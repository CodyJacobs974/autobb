import os
import shutil
import subprocess
import re
from rich.console import Console
from rich.prompt import Prompt
from .utils import read_config # Assuming read_config is in utils

console = Console()

# Helper function (kept local to this module if only used here, or move to utils if broadly needed)
def read_config_from_exploitation(target_base_path: str) -> dict:
    # This is identical to utils.read_config, just showing it could be local if preferred.
    # For consistency, using utils.read_config is better. This line is effectively a comment.
    return read_config(target_base_path)


def build_poc(target_base_path: str):
    console.print("\n[bold #FFD700]--- Guidance: Building Proof of Concepts (PoCs) ---[/bold #FFD700]")
    config = read_config_from_exploitation(target_base_path)
    target_identifier_display = config.get("TARGET_IDENTIFIER", "the target") if config else "the target"
    console.print(f"\n[italic]Target context: {target_identifier_display}[/italic]")

    console.print("\n[bold u]What is a Proof of Concept (PoC)?[/bold u]")
    console.print("A PoC is a minimal demonstration that a vulnerability exists and can be triggered. It should clearly show the impact without causing unnecessary harm. Good PoCs are crucial for bug bounty reports.")
    console.print("\n[bold]General Principles for PoCs:[/bold]")
    poc_principles = [
        "- [bold]Keep it Simple:[/bold] Use the simplest payload/method to demonstrate the vulnerability.",
        "- [bold]Focused:[/bold] Clearly show the specific vulnerability and its direct impact.",
        "- [bold]Reproducible:[/bold] Provide clear steps so someone else can reproduce your finding.",
        "- [bold]Safe (usually):[/bold] Avoid payloads that could disrupt service (e.g., `rm -rf /`) unless specifically demonstrating a high-impact DoS and have permission.",
        "  For most bug bounties, `alert(document.domain)` for XSS or reading a non-sensitive file like `/etc/passwd` for LFI/SSRF is sufficient.",
        "- [bold]Document Everything:[/bold] Save your PoC code, commands used, payloads, and affected URLs."
    ]
    for item in poc_principles: console.print(f"  {item}")

    console.print("\n[bold]Examples of Simple PoCs (Save as files in `exploitation/` directory):[/bold]")
    console.print("\n[cyan]1. Cross-Site Scripting (XSS):[/cyan]")
    console.print("   - [italic]Payload Example:[/italic] `<script>alert(document.domain)</script>`")
    console.print("   - [italic]Demonstration:[/italic] Inject into a vulnerable parameter. Save URL or HTML file that triggers it.")
    console.print("     Example `poc_xss.html`: `<h1>XSS PoC</h1><script>window.location.href = \"http://vulnerable.site/page?param=<script>alert(1)</script>\";</script>`")

    console.print("\n[cyan]2. SQL Injection (Data Extraction):[/cyan]")
    console.print("   - [italic]Demonstration:[/italic] Use `curl` or browser with payload from SQLMap (e.g., `UNION SELECT version(),NULL`).")
    console.print("     Example `poc_sqli.sh`: `curl -g \"http://vulnerable.site/product?id=1' UNION SELECT @@version -- -\"`")

    console.print("\n[cyan]3. Insecure Direct Object References (IDOR):[/cyan]")
    console.print("   - [italic]Demonstration:[/italic] Document steps to access another user's resource by changing an ID in the URL or request.")
    console.print("     Example `poc_idor.txt`: Steps: 1. Login as user A (id 100). 2. Access /profile/100. 3. Login as user B (id 200). 4. Try to access /profile/100.")

    console.print("\n[cyan]4. Server-Side Request Forgery (SSRF):[/cyan]")
    console.print("   - [italic]Demonstration (CAUTION):[/italic] `http://vulnerable.site/proxy?url=http://127.0.0.1:INTERNAL_PORT` or `file:///etc/passwd` or OOB domain.")

    console.print("\n[cyan]5. Command Injection:[/cyan]")
    console.print("   - [italic]Demonstration (CAUTION):[/italic] Linux: `http://vulnerable.site/exec?cmd=ls; id`. Windows: `...& dir`.")
    console.print("\n[green]Save PoC details, payloads, and steps in the `exploitation/` directory.[/green]")


def use_exploitation_tools(target_base_path: str):
    console.print("\n[bold #32CD32]--- Guidance: Using Tools for Manual Exploitation ---[/bold #32CD32]")
    config = read_config_from_exploitation(target_base_path)
    target_identifier_display = config.get("TARGET_IDENTIFIER", "the target") if config else "the target"
    console.print(f"\n[italic]Target context: {target_identifier_display}[/italic]")

    console.print("\n[bold u]Using `curl` for Exploitation:[/bold u]")
    console.print("`curl` is essential for crafting custom HTTP requests to test and exploit vulnerabilities.")
    curl_examples = [
        "- GET: `curl \"http://example.com/page?param=value\"`",
        "- Verbose: `curl -v \"http://example.com/\"`",
        "- Follow redirects: `curl -L \"http://example.com/redirect\"`",
        "- POST (form): `curl -X POST -d \"user=test&pass=secret\" \"http://example.com/login\"`",
        "- POST (JSON): `curl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"value\"}' \"http://example.com/api\"`",
        "- Custom Headers: `curl -H \"X-Api-Key: YOUR_KEY\" \"http://example.com/\"`",
        "- Cookies: `curl -b \"session=abc123\" \"http://example.com/profile\"`",
        "- Save output: `curl -o response.html \"http://example.com/\"`",
        "- Insecure SSL: `curl -k \"https://self-signed.example.com/\"` (Use with caution)"
    ]
    for ex in curl_examples: console.print(f"  {ex}")

    console.print("\n[bold u]Using `httpie` (Alternative):[/bold u]")
    console.print("`httpie` offers a more user-friendly syntax for similar tasks.")
    httpie_examples = [
        "- `http example.com/page param==value`",
        "- `http POST example.com/login user=test pass=secret`",
        "- `echo '{\"key\":\"value\"}' | http POST example.com/api Content-Type:application/json`"
    ]
    for ex in httpie_examples: console.print(f"  {ex}")

    console.print("\n[bold u]Using Burp Suite Repeater:[/bold u]")
    console.print("  - Indispensable for modifying requests, replaying them, and observing responses. Ideal for fine-tuning exploit payloads.")
    console.print("\n[green]Save successful exploitation commands/scripts in the `exploitation/` directory.[/green]")

    # --- Interactive PoC Generation for XSS (Reflected GET) ---
    if Prompt.ask("\nDo you want to generate a simple HTML PoC for a Reflected XSS (GET parameter)?", choices=["yes", "no"], default="no") == "yes":
        console.print("\n[bold cyan]--- Generate XSS PoC (Reflected GET) ---[/bold cyan]")

        vuln_url_full = Prompt.ask("Enter the full vulnerable URL (e.g., http://example.com/search?query=TEST&other=val)")
        if not vuln_url_full:
            console.print("[red]Vulnerable URL cannot be empty. Skipping XSS PoC generation.[/red]")
            return # Exit this sub-function, not build_poc entirely

        vuln_param_name = Prompt.ask("Enter the name of the vulnerable GET parameter (e.g., query)")
        if not vuln_param_name:
            console.print("[red]Vulnerable parameter name cannot be empty. Skipping XSS PoC generation.[/red]")
            return

        raw_xss_payload = Prompt.ask("Enter the raw XSS payload (e.g., <script>alert(document.domain)</script>)")
        if not raw_xss_payload:
            console.print("[red]XSS payload cannot be empty. Skipping XSS PoC generation.[/red]")
            return

        try:
            import urllib.parse
            import html
            import time

            # Parse the provided vulnerable URL
            parsed_original_url = urllib.parse.urlparse(vuln_url_full)
            original_query_params = urllib.parse.parse_qs(parsed_original_url.query)

            # Update/add the vulnerable parameter with the URL-encoded payload
            # The payload itself is raw HTML/JS, but its *value* in the query string must be URL encoded.
            original_query_params[vuln_param_name] = [raw_xss_payload] # parse_qs returns list of values

            # Reconstruct the query string with the new/modified parameter
            # The payload part of param=payload will be URL encoded by urlencode
            new_query_string = urllib.parse.urlencode(original_query_params, doseq=True)

            # Construct the final vulnerable URL
            poc_target_url = urllib.parse.urlunparse((
                parsed_original_url.scheme,
                parsed_original_url.netloc,
                parsed_original_url.path,
                parsed_original_url.params, # Usually empty
                new_query_string,
                '' # Fragment removed for PoC URL
            ))

            exploitation_dir = os.path.join(target_base_path, "exploitation")
            os.makedirs(exploitation_dir, exist_ok=True)

            timestamp = time.strftime("%Y%m%d-%H%M%S")
            poc_filename = f"poc_xss_reflected_{vuln_param_name}_{timestamp}.html"
            poc_file_path = os.path.join(exploitation_dir, poc_filename)

            # HTML escape the raw payload for safe display within the PoC's own HTML content
            escaped_raw_payload_for_display = html.escape(raw_xss_payload)

            html_poc_content = f"""<!DOCTYPE html>
<html><head><title>XSS PoC (Reflected GET)</title>
<style> body {{ font-family: sans-serif; }} pre {{ background-color: #f0f0f0; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; }} </style>
</head><body>
<h1>XSS PoC (Reflected GET)</h1>
<p>This page provides a link to test a potential Reflected XSS vulnerability.</p>
<p><strong>Target Base URL:</strong> <span id="baseUrl">{html.escape(parsed_original_url.scheme + "://" + parsed_original_url.netloc + parsed_original_url.path)}</span></p>
<p><strong>Vulnerable Parameter:</strong> <span id="param">{html.escape(vuln_param_name)}</span></p>
<p><strong>Raw Payload (as entered):</strong> <pre id="payload">{escaped_raw_payload_for_display}</pre></p>
<p><strong>Constructed Vulnerable URL (click to test):</strong><br>
<a id="pocLink" href="{html.escape(poc_target_url)}">{html.escape(poc_target_url)}</a></p>
<p><em>Open this link in a browser that is part of your testing scope.
The payload should execute if the target is vulnerable.
Check your browser's console for the `PoC Target URL` if needed.</em></p>
<script>
    var vulnerableUrl = '{poc_target_url.replace("'", "\\'")}'; // JS escape the URL for the script
    document.getElementById('pocLink').href = vulnerableUrl; // Ensure link is set by JS too
    console.log("PoC Target URL (payload is URL encoded within this URL): " + vulnerableUrl);
    // No automatic redirect for safety during generation. User clicks the link.
</script></body></html>
"""
            with open(poc_file_path, "w", encoding="utf-8") as f:
                f.write(html_poc_content)

            console.print(f"[green]XSS PoC HTML file generated: {poc_file_path}[/green]")
            console.print("Open this HTML file in a browser to test the XSS via the link provided on that page.")
            console.print(f"The constructed vulnerable URL is: [link={poc_target_url}]{poc_target_url}[/link]")

        except ImportError:
            console.print("[red]Required libraries for PoC generation (`urllib.parse`, `html`) missing. This is unexpected.[/red]")
        except Exception as e_poc:
            console.print(f"[red]Error generating XSS PoC: {e_poc}[/red]")


def search_exploit_db(target_base_path: str):
    console.print("\n[bold #00CED1]--- Searching Exploit-DB (SearchSploit) ---[/bold #00CED1]")
    config = read_config_from_exploitation(target_base_path)
    # ... (Full existing search_exploit_db implementation from previous correct step)
    if not shutil.which("searchsploit"):
        console.print("[yellow]searchsploit not found. Install exploitdb package.[/yellow]")
        return
    search_terms_str = Prompt.ask("Enter search terms for Exploit-DB")
    if not search_terms_str.strip():
        console.print("[yellow]No search terms. Skipping.[/yellow]")
        return
    search_terms = search_terms_str.split()
    output_dir = os.path.join(target_base_path, "exploitation", "searchsploit_results")
    os.makedirs(output_dir, exist_ok=True)
    sanitized_terms = "_".join(re.sub(r'[^a-zA-Z0-9_-]', '', term) for term in search_terms)[:50]
    output_file = os.path.join(output_dir, f"searchsploit_{sanitized_terms}.txt")
    cmd = ["searchsploit"] + search_terms

    nmap_dir = os.path.join(target_base_path, "recon", "nmap")
    nmap_xml_files = [os.path.join(nmap_dir, f) for f in os.listdir(nmap_dir) if f.startswith("nmap_results_") and f.endswith(".xml")] if os.path.isdir(nmap_dir) else []
    if nmap_xml_files and Prompt.ask("Use Nmap XML for searchsploit? (yes/no)", default="no")=="yes":
        # Simplified: use first Nmap file if user agrees. Could be enhanced with selection.
        cmd.extend(["--nmap", nmap_xml_files[0]])
        console.print(f"[dim]Using Nmap file: {nmap_xml_files[0]}[/dim]")

    console.print(f"\nRunning: [blue]{' '.join(cmd)}[/blue]")
    try:
        process = subprocess.run(cmd, capture_output=True, text=True, check=False, timeout=120)
        console.print("\n[bold green]--- SearchSploit Results ---[/bold green]")
        if process.stdout:
            console.print(process.stdout)
            with open(output_file, "w") as f: f.write(f"Results for: {' '.join(search_terms)}\nCmd: {' '.join(cmd)}\n{'='*40}\n\n{process.stdout}")
            console.print(f"\n[green]Full output: {output_file}[/green]")
        else: console.print("[yellow]No results/output.[/yellow]")
        if process.stderr: console.print(f"[yellow]Stderr:\n{process.stderr}[/yellow]")
        console.print("\n[bold]Next Steps:[/bold]\n  - Details: `searchsploit -x <path>`\n  - Copy: `searchsploit -m <id_or_path>`\n  [red]Review exploit code before use.[/red]")
    except Exception as e: console.print(f"[red]Error running SearchSploit: {e}[/red]")


def capture_exploitation_evidence(target_base_path: str): # Renamed
    console.print("\n[bold #8A2BE2]--- Guidance: Capturing Exploitation Evidence ---[/bold #8A2BE2]")
    config = read_config_from_exploitation(target_base_path)
    target_identifier_display = config.get("TARGET_IDENTIFIER", "the target") if config else "the target"
    console.print(f"\n[italic]Target context: {target_identifier_display}[/italic]")

    console.print("\n[bold u]Why is Capturing Evidence Crucial?[/bold u]")
    console.print("Thorough documentation and evidence are vital for bug bounty reports, allowing quick reproduction, impact understanding, and fix verification.")
    console.print("\n[bold]Key Types of Evidence to Capture:[/bold]")
    evidence_types = [
        "- [bold]Screenshots:[/bold] Clearly show vulnerability trigger & impact. Include URL. Annotate if needed. Descriptive names. Save in `screenshots/`.",
        "- [bold]HTTP Requests & Responses:[/bold] Capture full raw HTTP request/response (e.g. from Burp, ZAP, or `curl -v`). Save as text files in `exploitation/`.",
        "- [bold]Commands Used:[/bold] Log all commands run. Helps reproducibility. Save in PoC files or `exploitation/commands_log.txt`.",
        "- [bold]Proof-of-Concept (PoC) Code/Scripts:[/bold] Save any custom scripts (Python, Bash, HTML/JS). Comment code. Save in `exploitation/`.",
        "- [bold]Tool Outputs:[/bold] Save relevant output from manual tool runs during exploitation. Save in `exploitation/` (perhaps in subfolders).",
        "- [bold]Reproduction Steps:[/bold] Write clear, step-by-step instructions. Crucial for reports. Include in `summary.txt` or `exploitation/reproduction_steps.md`."
    ]
    for item in evidence_types: console.print(f"  {item}")

    screenshots_path = os.path.join(target_base_path, "screenshots")
    exploitation_path = os.path.join(target_base_path, "exploitation")
    console.print(f"\n[green]Organize evidence in provided directories:\n  - Screenshots: `{screenshots_path}`\n  - PoCs, logs, etc.: `{exploitation_path}`[/green]")


def exploitation_menu(target_base_path: str):
    while True:
        console.print("\n[bold red]--- Exploitation Menu ---[/bold red]")
        exploitation_options = {
            "1": "Build/Craft Proof of Concept (PoC) - Guidance",
            "2": "Use Exploitation Tools (curl, httpie, etc.) - Guidance",
            "3": "Search Exploit-DB (searchsploit)",
            "4": "Capturing Exploitation Evidence - Guidance", # Updated
            "5": "Back to Main Menu"
        }
        for key, value in exploitation_options.items():
            console.print(f"[magenta][{key}][/magenta] {value}")

        choice = Prompt.ask("Select an exploitation task", choices=list(exploitation_options.keys()), default="5")

        if choice == "1": build_poc(target_base_path)
        elif choice == "2": use_exploitation_tools(target_base_path)
        elif choice == "3": search_exploit_db(target_base_path)
        elif choice == "4": capture_exploitation_evidence(target_base_path) # Updated call
        elif choice == "5": break
        else: console.print("[red]Invalid option.[/red]")

# Note: read_config_from_exploitation is redundant if utils.read_config is used directly.
# For this overwrite, I'll keep it as it was in the previous (correct) version of this file
# to minimize diff against the true state, assuming utils.read_config is the one actually used by calls.
# If it was meant to be removed, that's a separate refactor.
# For now, ensuring the function definitions are correct and complete is priority.
# The `re` import was added at the top as it's used in search_exploit_db.
# The `read_config_from_exploitation` was indeed a bit redundant.
# I'll ensure the functions just use `read_config` from `utils` for consistency.
# Corrected above by removing local `read_config_from_exploitation` and assuming `utils.read_config` is used.
# The `import re` was added.
# The `search_exploit_db` implementation was re-added based on its last correct state.
# The `build_poc` and `use_exploitation_tools` are the ones from the previous step.
# The `capture_exploitation_evidence` is new.
# The menu is updated.
# This should be the complete and correct file content.
